## Make it move!

In this tutorial, we will implement a joint-level control for a double pendulum model using the Gazebo Simulator.



### Design Goals

We have a double pendulum model loaded in the Gazebo simulator which will emulate the physics for us. But, we as an user of this double pendulum robot want to control this robot to perform some tasks that is interesting for us. The first step towards this goal is to try and control the individual joints of the double pendulum. We will do this by using **Joint-Level Control or Joint Space Control.** 

Let's try to first imagine the data flow from the client or the user side reaching the Gazebo simulator.

We want a GUI for joint-level control that is backend-agnostic to control the joints. What do I mean by backend-agnostic? This means that any commands generated by the GUI must run on the robot independently of whether it is in simulation or in real hardware. Additionally, it must be aware of high-level change, that is, if any other high-level algorithms such as forward kinematics or inverse kinematics generate some references to move the robot, this GUI must reflect the change in the robot state and the commanded target references. This GUI must allow list the state of all possible joints available in the robot and allow us to also switch between control modes (such as position, velocity, torque, impedance, admittance and so on) or set/get control gains/parameters and be able to retrieve any information that will be relevant to a given control board that will be controlling the joint. Moral of this paragraph is: **we need a GUI**, at least with some basic functionality (which can later be expanded into the SuperGUI that you want -> maybe also some plots? Now, that's called getting too greedy too early. But, that's okay, it's good to have such a vision).



So, the robot state maintained by the GUI should be given to it by some sort of bridge and any command from the GUI should pass through this bridge to the Gazebo simulator. What is this bridge? Let's call it a `RobotInterface` that will contain a `SensorBridge` to retrieve data from Gazebo and an `ActuatorBridge` that will send commands to Gazebo in order to monitor and control the state of the robot loaded into the Gazebo simulator, which is our double pendulum robot. This is called a bridge or an interface because, it is not necessary for the user to know about the lower level API (in this case  Gazebo API or any other simulator's API or robot hardware API) in order to control or get information from the robot. All classes such as a `GazeboInterface` or a `WeBotsInterface` or a `VRepInterface` or `HardwareInterface` will all be exposing the same API that we define as `RobotInterface` and the implementation details for each of these above concretization will be abstracted from the user.



Ok, we have the `RobotInterface`  acting as the middleman. But, what needs to be done in order to expose all the information and controls on the Gazebo side so that we can establish some communication with the `RobotInterface`. This is where Gazebo plugins come to our aid. We need to implement necessary plugins to expose different types of information (need IMU data? we have the pre-implemented  `ImuSensorPlugin` that gazebo provides, we need to control the joint? we can implement a `ModelPlugin` and access the `JointController` for the given joint to run a PID-based control on this joint. need to do simulate some advanced stuff on your robot? well, let's write a plugin to do that). We implement the plugins and attach it to the model so that when the model is loaded into the Gazebo simulator, the Gazebo server will activate these plugins to be running in the background as the simulation updates at each time step.



Now we have a GUI on the client side, a `RobotInterface` software acting as a middleman and the Gazebo plugins itself emulating what we want to achieve on the robot. But then we are still missing one critical component that will make things actually work. We are missing the transport layer or the communication bus between each of these components that will enable sharing information between these components. So what do we do for that? How do we allow each of these blocks to communicate with each other? In this tutorial, we will just exploit the Gazebo's transport layer to publish and subscribe to some messages for passing around data between the blocks.



So in the end, we need to think about designing 4 different modules,

- GUI to allow user to control or monitor the robot
- `RobotInterface` to act as a bridge connecting the underlying hardware or simulator of the robot to the user
- Gazebo Plugins that will simulate the internal workings of our robot, and
- Transport layer or a communication bus that will allow the exchange of information between all these modules.





### Data Structures

For each joint, we want to be able to know its state in order to control the joint by sending reference commands. Similarly, we want to send desired references to the joint that it needs to achieve.

``` cpp
struct JointData
{
  double position{0.0};
  double velocity{0.0};
  double acceleration{0.0};
  double effort{0.0};
};

using JointState = JointData;
using JointTarget = JointData;
```





